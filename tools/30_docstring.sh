#!/usr/bin/env bash

# Generates documentation markdown for each module in ./src/,
# copies associated images, and builds ./docs/INDEX.md and ./docs/README.md.
# See ./src/* for modules and ./src/*.conf for metadata.

DOC_ROOT="./docs"
SRC_ROOT="./src"

# Find all shell module files in ./src/
find_modules() {
	find "$SRC_ROOT" -type f -name "*.sh" | sort
}

# Extracts metadata from .conf file for docs
extract_metadata() {
	local conf_file="$1"
	echo "# $(grep '^feature=' "$conf_file" | cut -d= -f2- | xargs)"
	description=$(grep '^description=' "$conf_file" | cut -d= -f2- | xargs)
	[ -n "$description" ] && echo "$description"
	echo
	extend_desc=$(grep '^extend_desc=' "$conf_file" | cut -d= -f2- | xargs)
	[ -n "$extend_desc" ] && echo "## About"$'\n'"$extend_desc"$'\n'
}

# Extracts help output from the shell module (runs _about_modname if available)
extract_help() {
	local sh_file="$1"
	local modname
	modname="$(basename "$sh_file" .sh)"
	help_msg=$(bash -c "
		source \"$sh_file\"
		type _about_${modname} &>/dev/null && _about_${modname}
	" 2>/dev/null || true)
	if [ -n "$help_msg" ]; then
		echo "## Usage"$'\n'"~~~bash"$'\n'"$help_msg"$'\n'"~~~"$'\n'
	else
		echo "## Usage"$'\n'"No help available for $modname"$'\n'
	fi
}

# Finds image for a module, copies it to ./docs/, and emits markdown if found
copy_and_markdown_image() {
	local modname="$1"
	local src_dir="$2"
	for ext in png jpg jpeg gif svg; do
		local img="${src_dir}/${modname}.${ext}"
		if [[ -f "$img" ]]; then
			cp "$img" "$DOC_ROOT/"
			echo "![${modname} image](./${modname}.${ext})"$'\n'
			return
		fi
	done
}

# Extract parent from .conf for grouping
get_parent() {
	local conf="$1"
	grep -E '^parent=' "$conf" | head -n1 | cut -d= -f2- | xargs
}

# Extract group from .conf for grouping
get_group() {
	local conf="$1"
	grep -E '^group=' "$conf" | head -n1 | cut -d= -f2- | xargs
}

# Grab summary (first non-header, non-empty line) from module doc
get_summary() {
	local md="$1"
	awk 'NR>1 && NF && $0 !~ /^#/' "$md" | head -n1
}

# Generate per-module docs from .sh and .conf
generate_module_docs() {
	rm -rf "$DOC_ROOT"
	mkdir -p "$DOC_ROOT"
	while IFS= read -r sh_file; do
		modname="$(basename "$sh_file" .sh)"
		conf_file="$(dirname "$sh_file")/${modname}.conf"
		md_file="${DOC_ROOT}/${modname}.md"
		if [[ ! -f "$conf_file" ]]; then
			echo "Skipping $sh_file: missing $conf_file"
			continue
		fi
		{
			extract_metadata "$conf_file"
			copy_and_markdown_image "$modname" "$(dirname "$sh_file")"
			extract_help "$sh_file"
			echo "- Autogenerated from \`$conf_file\` and \`$sh_file\`"
		} > "$md_file"
		echo "Generated $md_file"
	done < <(find_modules)
}

# Generate a flat index of all docs in ./docs/INDEX.md
generate_docs_flat_index() {
	echo "# Module Documentation" > "$DOC_ROOT/INDEX.md"
	echo >> "$DOC_ROOT/INDEX.md"
	i=1
	for md in "$DOC_ROOT"/*.md; do
		[[ "$md" == "$DOC_ROOT/INDEX.md" ]] && continue
		mod_name="$(basename "$md" .md)"
		summary="$(get_summary "$md")"
		echo "${i}. [${mod_name}](./${mod_name}.md)${summary:+ — $summary}" >> "$DOC_ROOT/INDEX.md"
		((i++))
	done
}

# Generate a grouped index in ./docs/README.md using parent and group
generate_docs_index() {
	echo "# Module Documentation" > "$DOC_ROOT/README.md"
	echo >> "$DOC_ROOT/README.md"
	declare -A tree

	while IFS= read -r sh_file; do
		modname="$(basename "$sh_file" .sh)"
		conf_file="$(dirname "$sh_file")/${modname}.conf"
		md_file="${modname}.md"
		parent="NoParent"
		group="Ungrouped"
		if [[ -f "$conf_file" ]]; then
			p="$(get_parent "$conf_file")"
			[[ -n "$p" ]] && parent="$p"
			g="$(get_group "$conf_file")"
			[[ -n "$g" ]] && group="$g"
		fi
		tree["$parent|$group"]+="${tree["$parent|$group"]:+$'\n'}${modname}|$md_file"
	done < <(find_modules)

	mapfile -t parents < <(for k in "${!tree[@]}"; do echo "${k%%|*}"; done | sort -u)
	for parent in "${parents[@]}"; do
		echo "## $parent" >> "$DOC_ROOT/README.md"
		mapfile -t groups < <(for k in "${!tree[@]}"; do [[ "${k%%|*}" == "$parent" ]] && echo "${k#*|}"; done | sort -u)
		for group in "${groups[@]}"; do
			echo "- $group" >> "$DOC_ROOT/README.md"
			key="${parent}|${group}"
			while IFS='|' read -r mod_name md_file; do
				[[ -z "$mod_name" ]] && continue
				md_path="./${md_file}"
				summary="$(get_summary "$DOC_ROOT/$md_file")"
				echo "    - [${mod_name}](${md_path})${summary:+ — $summary}" >> "$DOC_ROOT/README.md"
			done <<< "${tree["$key"]}"
		done
		echo >> "$DOC_ROOT/README.md"
	done
}

_conf_to_json() {
	find "$SRC_ROOT" -type f -name '*.conf' | while read -r conf; do
		# Extract section name
		section=$(awk '/^\[.*\]/ {gsub(/^\[|\]$/, "", $0); print $0; exit}' "$conf")

		# Build JSON object
		(
		echo "{"
		echo "\"module\": \"$section\""

		# Extract key-value pairs, handle multiple '=' properly
		grep -E '^[[:space:]]*[^#\[].*=' "$conf" | while read -r line; do
			# Split on first '=' only using bash parameter expansion
			key="${line%%=*}"
			value="${line#*=}"

			# Trim whitespace
			key=$(echo "$key" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
			value=$(echo "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

			# Use jq to properly escape the value
			echo ",\"$key\": $(echo "$value" | jq -R .)"
		done
		echo "}"
		) | jq -s add  # Combine lines into single JSON object
	done | jq -s '
		# Nest by .parent, .group, .module as before
		reduce .[] as $item ({};
		.[$item.parent][$item.group][$item.module] = ($item | del(.parent, .group, .module))
		)
'
}


show_help() {
	echo "Usage: $0 [OPTIONS]"
	echo
	echo "Generates module documentation and indexes."
	echo
	echo "Options:"
	echo "  -h, --help    Show this help message and exit"
}

main() {
	case "$1" in
		-h|--help)
			show_help
			exit 0
			;;
		""|*)
			generate_module_docs
			generate_docs_flat_index
			generate_docs_index
			_conf_to_json > $DOC_ROOT/modules_metadat.json

			;;
	esac


}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	main "$@"
fi
