#!/usr/bin/env bash


# Get absolute path to the directory containing this script
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Set project root as the parent directory of SCRIPT_DIR
ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
LIB_DIR="$ROOT_DIR/lib/armbian-config"
SRC_ROOT="$ROOT_DIR/src"
DOC_ROOT="$ROOT_DIR/docs"

_about_json2docs() {
		cat <<EOF

Usage: $0 <json-file> <template-html> <output-html>

Inject a JSON object into the Configng V2 HTML docs template.

Arguments:
	<json-file>      Path to the JSON object file (object only, no JS assignment)
	<template-html>  Path to the HTML template with JSON block markers
	<output-html>    Where to write the generated docs HTML

Example:
	$0 data/menu.json workflow/main.html docs/modules-menu-simple-dark.html

Notes:
	- This does NOT overwrite your template or data file.
	- Injection replaces only the marked block, preserving everything else.
	- Intended for @Tearran/configng-v2 documentation and menu generation.

EOF
}

_add_auto_generated_warning() {
	local output_file="$1"
	local source_file="$2"
	local description="$3"

	# Create the warning comment
	local warning_comment="<!--
WARNING: This file is AUTO-GENERATED by workflow/35_web_docs.sh
DO NOT EDIT THIS FILE DIRECTLY!

$description

To make changes, edit the source file instead:
Source: $source_file

Then run: ./workflow/35_web_docs.sh

This warning is automatically added to prevent confusion between
source and generated files. See issue #72 for details.
-->"

	# Add warning after the opening <html> tag
	awk -v warning="$warning_comment" '
		/<html[^>]*>/ {
			print
			print warning
			next
		}
		{ print }
	' "$output_file" > "$output_file.tmp" && mv "$output_file.tmp" "$output_file"
}

json2docs() {
	if [[ $# -ne 3 ]]; then
		echo "Error: Missing argument(s). See --help for usage." >&2
		return 1
	fi

	local JSON_FILE="$1"
	local TEMPLATE_FILE="$2"
	local OUT_FILE="$3"

	if [[ ! -f "$JSON_FILE" ]]; then
		echo "Error: JSON file '$JSON_FILE' not found." >&2
		return 2
	fi

	if [[ ! -f "$TEMPLATE_FILE" ]]; then
		echo "Error: Template HTML file '$TEMPLATE_FILE' not found." >&2
		return 3
	fi

	local NEW_JSON JS_ASSIGN
	NEW_JSON="$(cat "$JSON_FILE")"
	# Escape the sentinel string `</script>` so that it is harmless when embedded.
	# We only need to mangle the closing tag, leaving JSON intact for JS.
	safe_json=${NEW_JSON//<\/script>/<\\/script>}
	JS_ASSIGN=$'\tconst JSON_URL = '"$safe_json"';'
	awk -v js="$JS_ASSIGN" '
	BEGIN {inblock=0}
	{
		if ($0 ~ /\/\/ ----- BEGIN: Easy-to-edit JSON/) {
			inblock=1
			print
			print js
			next
		}
		if ($0 ~ /\/\/ ----- END: Easy-to-edit JSON/) {
			inblock=0
			print
			next
		}
		if (!inblock) print
	}
	' "$TEMPLATE_FILE" > "$OUT_FILE"

	# Add auto-generated warning
	_add_auto_generated_warning "$OUT_FILE" "$TEMPLATE_FILE" "This file contains dynamically injected JSON data from module configuration files."

	echo "OK: Generated $OUT_FILE"
}


_conf_to_json() {
	find "$SRC_ROOT" -type f -name '*.conf' | while read -r conf; do
		# Extract section name
		section=$(awk '/^\[.*\]/ {gsub(/^\[|\]$/, "", $0); print $0; exit}' "$conf")

		# Build JSON object
		(
		echo "{"
		echo "\"module\": \"$section\""

		# Extract key-value pairs, handle multiple '=' properly
		grep -E '^[[:space:]]*[^#\[].*=' "$conf" | while read -r line; do
			# Split on first '=' only using bash parameter expansion
			key="${line%%=*}"
			value="${line#*=}"

			# Trim whitespace
			key=$(echo "$key" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
			value=$(echo "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

			# Use jq to properly escape the value
			echo ",\"$key\": $(echo "$value" | jq -R .)"
		done
		echo "}"
		) | jq -s add  # Combine lines into single JSON object
	done | jq -s '
		# Nest by .parent, .group, .module as before
		reduce .[] as $item ({};
		.[$item.parent][$item.group][$item.module] = ($item | del(.parent, .group, .module))
		)
'
}

web_docs(){
	case "${1:-}" in
		-h|--help|help)
			_about_json2docs
			;;
		*)
			echo "Please wait: Nesting may take a few moments to complete"


			_conf_to_json > "$ROOT_DIR/docs/modules_metadata.json"
			echo "OK: Generated ./docs/modules_metadata.json"


			cp "$ROOT_DIR/workflow/index.html" "$ROOT_DIR/docs/modules_browser.html"
			echo "OK: Copied ./workflow/index.html to ./docs/modules_browser.html"


			cp "$ROOT_DIR/docs/modules_metadata.json" "$ROOT_DIR/modules_browsers/modules_metadata.json" || exit 1
			echo "OK: Copied ./docs/modules_metadata.json to ./modules_browsers/modules_metadata.json"


			json2docs "${1:-$ROOT_DIR/docs/modules_metadata.json}" "${2:-$ROOT_DIR/workflow/index.html}" "${3:-$ROOT_DIR/modules_browsers/modules_browser.html}"
			echo "OK: injeted json for onefile wepage"


			_add_auto_generated_warning "$ROOT_DIR/docs/modules_browser.html" "$ROOT_DIR/workflow/index.html" "This file is a direct copy of the source template."
			echo "OK: Added generated message to ./docs/modules_browser.html"

			;;
	esac
}

# Generates documentation markdown for each module in ./src/,
# copies associated images, and builds and ./docs/README.md.
# See ./src/* for modules and ./src/*.conf for metadata.

# Find all shell module files in ./src/
find_modules() {
	find "$SRC_ROOT" -type f -name "*.sh" | sort
}

# Extracts metadata from .conf file for docs
extract_metadata() {
	local conf_file="$1"
	echo "# $(grep '^feature=' "$conf_file" | cut -d= -f2- | xargs)"
	description=$(grep '^description=' "$conf_file" | cut -d= -f2- | xargs)
	[ -n "$description" ] && echo "$description"
	echo
	extend_desc=$(grep '^extend_desc=' "$conf_file" | cut -d= -f2- | xargs)
	[ -n "$extend_desc" ] && echo "## About"$'\n'"$extend_desc"$'\n'
}

# Extracts help output from the shell module (runs _about_modname if available)
extract_help() {
	local sh_file="$1"
	local modname
	modname="$(basename "$sh_file" .sh)"
	help_msg=$(bash -c "
		source \"$sh_file\"
		type _about_${modname} &>/dev/null && _about_${modname}
	" 2>/dev/null || true)
	if [ -n "$help_msg" ]; then
		echo "## Usage"$'\n'"~~~bash"$'\n'"$help_msg"$'\n'"~~~"$'\n'
	else
		echo "## Usage"$'\n'"No help available for $modname"$'\n'
	fi
}

# Finds image for a module, copies it to ./docs/, and emits markdown if found
copy_and_markdown_image() {
	local modname="$1"
	local src_dir="$2"
	for ext in png jpg jpeg gif svg; do
		local img="${src_dir}/${modname}.${ext}"
		if [[ -f "$img" ]]; then
			cp "$img" "$DOC_ROOT/"
			echo "![${modname} image](./${modname}.${ext})"$'\n'
			return
		fi
	done
}

# Extract parent from .conf for grouping
get_parent() {
	local conf="$1"
	grep -E '^parent=' "$conf" | head -n1 | cut -d= -f2- | xargs
}

# Extract group from .conf for grouping
get_group() {
	local conf="$1"
	grep -E '^group=' "$conf" | head -n1 | cut -d= -f2- | xargs
}

# Grab summary (first non-header, non-empty line) from module doc
get_summary() {
	local md="$1"
	awk 'NR>1 && NF && $0 !~ /^#/' "$md" | head -n1
}

# Generate per-module docs from .sh and .conf
generate_module_docs() {
	rm -rf "$DOC_ROOT"
	mkdir -p "$DOC_ROOT"
	while IFS= read -r sh_file; do
		modname="$(basename "$sh_file" .sh)"
		conf_file="$(dirname "$sh_file")/${modname}.conf"
		md_file="${DOC_ROOT}/${modname}.md"
		if [[ ! -f "$conf_file" ]]; then
			echo "Skipping $sh_file: missing $conf_file"
			continue
		fi
		{
			extract_metadata "$conf_file"
			copy_and_markdown_image "$modname" "$(dirname "$sh_file")"
			extract_help "$sh_file"
			echo "- Autogenerated from \`$conf_file\` and \`$sh_file\`"
		} > "$md_file"
		echo "OK: Generated $md_file"
	done < <(find_modules)
	echo "OK: End of generate_module_docs"
}

# Generate a grouped index in ./docs/README.md using parent and group
generate_docs_index() {
	echo "# Module Documentation" > "$DOC_ROOT/README.md"
	echo >> "$DOC_ROOT/README.md"
	declare -A tree

	while IFS= read -r sh_file; do
		modname="$(basename "$sh_file" .sh)"
		conf_file="$(dirname "$sh_file")/${modname}.conf"
		md_file="${modname}.md"
		parent="NoParent"
		group="Ungrouped"
		if [[ -f "$conf_file" ]]; then
			p="$(get_parent "$conf_file")"
			[[ -n "$p" ]] && parent="$p"
			g="$(get_group "$conf_file")"
			[[ -n "$g" ]] && group="$g"
		fi
		tree["$parent|$group"]+="${tree["$parent|$group"]:+$'\n'}${modname}|$md_file"
	done < <(find_modules)

	mapfile -t parents < <(for k in "${!tree[@]}"; do echo "${k%%|*}"; done | sort -u)
	for parent in "${parents[@]}"; do
		echo "## $parent" >> "$DOC_ROOT/README.md"
		mapfile -t groups < <(for k in "${!tree[@]}"; do [[ "${k%%|*}" == "$parent" ]] && echo "${k#*|}"; done | sort -u)
		for group in "${groups[@]}"; do
			echo "- $group" >> "$DOC_ROOT/README.md"
			key="${parent}|${group}"
			while IFS='|' read -r mod_name md_file; do
				[[ -z "$mod_name" ]] && continue
				md_path="./${md_file}"
				summary="$(get_summary "$DOC_ROOT/$md_file")"
				echo "    - [${mod_name}](${md_path})${summary:+ â€” $summary}" >> "$DOC_ROOT/README.md"
			done <<< "${tree["$key"]}"
		done
		echo >> "$DOC_ROOT/README.md"
	done
}

show_help() {
	echo "Usage: $0 [OPTIONS]"
	echo
	echo "Generates module documentation and indexes."
	echo
	echo "Options:"
	echo "  -h, --help    Show this help message and exit"
}

main() {
	case "${1:-}" in
		-h|--help)
			show_help
			exit 0
			;;
		""|*)

			generate_module_docs
			echo "OK: Finished generate_module_docs"

			generate_docs_index
			echo "OK: Finished generate_docs_index"

			echo "NOTE: Nesting may take a few moments to complete"
			_conf_to_json > "$ROOT_DIR/docs/modules_metadata.json"
			echo "OK: Generated ./docs/modules_metadata.json"

			cp "$ROOT_DIR/workflow/index.html" "$ROOT_DIR/docs/modules_browser.html"
			echo "OK: Copied ./workflow/index.html to ./docs/modules_browser.html"

			cp "$ROOT_DIR/docs/modules_metadata.json" "$ROOT_DIR/modules_browsers/modules_metadata.json"
			echo "OK: Copied ./docs/modules_metadata.json to ./modules_browsers/modules_metadata.json"

			json2docs "${1:-$ROOT_DIR/docs/modules_metadata.json}" "${2:-$ROOT_DIR/workflow/index.html}" "${3:-$ROOT_DIR/modules_browsers/modules_browser.html}"
			echo "OK: injected json for onefile webpage"

			_add_auto_generated_warning "$ROOT_DIR/docs/modules_browser.html" "$ROOT_DIR/workflow/index.html" "This file is a direct copy of the source template."
			echo "OK: Added generated message to ./docs/modules_browser.html"
			;;
	esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	main "$@"
fi
